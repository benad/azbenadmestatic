---toml
title = "APJ 6: The Future"
date = "2009-11-28T10:58:00-05:00"
permalink = "blog/2009/11/28/apj-6-the-future/"
---

Let me finish this long series (<a title="Introduction" href="/blog/2009/8/6/a-programmers-journey.html" id="htu1">Introduction</a> and Parts <a title="1" href="/blog/2009/8/6/apj-1-hypertalk-and-applescript.html" id="ulq5">1</a>, <a title="2" href="/blog/2009/8/25/apj-2-c-transcription.html" id="o.09">2</a>, <a title="3" href="/blog/2009/8/25/apj-3-c-transcription.html" id="tydf">3</a>, <a title="4" href="/blog/2009/9/20/apj-4-learning-perl-transcription.html" id="o:-j">4</a> and <a title="5" href="/blog/2009/11/14/apj-5-java-transcription.html" id="la18">5</a>) without an audio post.<br>
 <br>
 As I referred in <a title="Part 1" href="http://benad.livejournal.com/21487.html" id="gfxq">Part 1</a>, what prompted me to start reminiscing about my experience and evolution as a programmer was <a title="this post" href="http://lists.canonical.org/pipermail/kragen-tol/2007-March/000849.html" id="e-8:">this post</a> by Kragen Javier Sitaker. In one of his "phase" was "Learning How Magic and Beauty are Possible", he discovered that well-made algorithms can be beautiful. As he later started to work, he faced the realities of practical software development rather than just "beautiful" software code. Sadly, I knew many programmers that were stuck in that phase of insisting on algorithmic beauty, and do so with arrogance.<br>
<br>
In a way, while I have great admiration for good computer scientists, I
see myself more and more becoming a kind of "elegant hacker", or
"software engineer" if I want to be pretentious. And, personally, I never really liked mathematics, regardless of my natural talent for it. My attention is more and more focused on run-time integration rather than the mathematical perfection of a few lines of code. After all, beautiful code is not always useful. I also greatly dislike "over-engineering" of code, and most forms of code generation. Small, to-the-point and modular code is what I like most. With the context of my experiences with C++ and Perl in a commercial programming environment, this should make more sense.<br>
<br>
Practically, I'm focusing more and more my learning into technologies like the <a title="Spring framework" href="http://www.springsource.org/about" id="rj9v">Spring framework</a>, run-time kernels like <a title="OSGi" href="http://en.wikipedia.org/wiki/OSGi" id="o931">OSGi</a>, continuous integration with <a title="Hudson" href="http://hudson-ci.org/" id="tjis">Hudson</a>, distributed version control with <a title="Mercurial" href="http://en.wikipedia.org/wiki/Mercurial" id="qk4d">Mercurial</a>, and so on. Also, as I mentioned in the <a title="previous part" href="http://benad.livejournal.com/24723.html" id="fi1l">previous part</a>, I'm interested into higher-level scripting languages like <a title="Groovy" href="http://groovy.codehaus.org/" id="rbd8">Groovy</a> that run on top of the Java virtual machine. That's all I can foresee for now. For sure, though, whatever I'll try, I'll be very opinionated about it.<br>
