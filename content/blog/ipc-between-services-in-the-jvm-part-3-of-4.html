---toml
title = "IPC between services in the JVM: Part 3 of 4"
date = "2010-07-29T12:32:00-04:00"
permalink = "blog/2010/7/29/ipc-between-services-in-the-jvm-part-3-of-4/"
---

<div class="posterous_autopost"><p><strong>Shared Objects</strong></p>  <p>In &ldquo;UNIX System V&rdquo;, and OSes similar to it, there are basically two forms of inter-process communication: shared memory and message queues. In the case of OSGi inter-module communications, its service references kind of makes using shared objects the obvious choice.</p>  <p>While UNIX-like systems and their enforced memory protection force you to have to explicitly request shared memory regions, in OSGi all the modules run under the same object memory space, so all objects can be potentially shared. This means that for OSGi modules you can use a service reference that contains shared values that can be accessed directly or through accessor functions as a mean of implementing inter-module communications.</p>  <p>Now, the issue is that in typical cases different modules run in different threads, so sharing objects between them requires careful use of locking mechanisms. And this is the problem with this &ldquo;shared memory&rdquo; approach: it simple cases na√Øve locking works fine, in more complex cases you get deadlocks and obscure race conditions.</p>  <p>Using an embedded relational database like <a href="http://www.oracle.com/technetwork/java/javadb/overview/index.html">JavaDB</a> or <a href="http://www.h2database.com/">H2</a> to simplify the locking semantics while keeping high parallelism seems like a good idea, but those embedded databases ultimately use a single lock for the entire process as the database write lock, making parallelism limited for inter-module communications.</p></div>
