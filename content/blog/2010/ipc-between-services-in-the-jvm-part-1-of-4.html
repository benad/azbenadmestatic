---toml
title = "IPC between services in the JVM: Part 1 of 4"
date = "2010-06-03T13:21:00-04:00"
permalink = "blog/2010/6/3/ipc-between-services-in-the-jvm-part-1-of-4/"
---

<div class="posterous_autopost"><h3>Learning About OSGi</h3>  <p>When I started learning about <a href="http://www.osgi.org/">OSGi</a> in late 2008, it felt quite simple, mostly due to the <a href="http://www.osgi.org/Release4/Download">specification</a>&rsquo;s clarity and design. But a year ago I thought that designing code for OSGi might give me the greatest challenge I&rsquo;ve ever had with software design. Or so I thought until I realized those design &ldquo;challenges&rdquo; were solved decades ago.</p>  <p>Here are few examples of those &ldquo;challenges&rdquo;. First, I noticed that most examples I&rsquo;ve seen for a service bundle and its client are separated by an API bundle of some kind. Makes sense, I thought, as using an interface between the provider of a service and its user makes it possible to replace the service implementation. But, actually, those API bundles were not made for that at all. The class instances passed from the service to its client, through whatever interface, must not be created by the classloader of the service&rsquo;s package, otherwise if the service is unloaded its classloader will &ldquo;leak&rdquo; in memory until all of its created object instances are garbage-collected. Since the instance&rsquo;s package defines what bundle&rsquo;s classloader to use to create it, then defining those &ldquo;interface beans&rdquo; in an API bundle prevents that &ldquo;classloader leak&rdquo; problem.</p>  <p>Second, you shouldn&rsquo;t be using <code>BundleContext.getServiceReferences(String, String)</code>, unless you&rsquo;re planning on calling <code>BundleContext.ungetService(ServiceReference)</code> on all of them right away. Actually, if you want to &ldquo;bind&rdquo; a bundle to some service by getting its <code>ServiceReference</code>, you should do so outside of <code>BundleActivator.start()</code>, because it &ldquo;must complete and return to its caller in a timely manner&rdquo; and you can&rsquo;t block to wait for another service to start. Actually, you should use a <code>ServiceListener</code> and listen for service registration asynchronously, so if you <em>really</em> want to &ldquo;block&rdquo; in <code>start()</code>, instead start a thread that gets awakened by <code>ServiceListener</code> events.</p>  <p>That second point introduced me to a new perspective on how lifecycle initialization in IoC and modular systems <em>actually</em> imply.</p>  </div>
