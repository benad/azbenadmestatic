---toml
title = "IPC between services in the JVM: Part 2 of 4"
date = "2010-07-04T07:14:00-04:00"
permalink = "blog/2010/7/4/ipc-between-services-in-the-jvm-part-2-of-4/"
---

<div class='posterous_autopost'><p><strong>Microkernels</strong></p>  <p>I first started to look into the Inversion of Control pattern only to reduce coupling between my classes. When I was &ldquo;shopping around&rdquo; for some IoC library, some described themselves as &ldquo;microkernels&rdquo;. I admit that Java is also a virtual <em>machine</em>, but I always though that a kernel is primarily for hardware abstraction and running multiple processes at once (at least since the 90s).</p>  <p>Yet those IoC libraries kept describing modules as &ldquo;services&rdquo;. In a way, a Singleton is a service, but in that sense lifecycle is restricted to initialization ordering, since once a Singleton-like service is loaded it stays in memory.</p>  <p>Actually, &ldquo;service&rdquo; or &ldquo;process&rdquo; patterns, that is run-time design, are orthogonal to &ldquo;linking&rdquo; patterns, that is coupling design. Naively I was focused only on coupling because in my UI-centric designs there are only a single thread, the UI event thread, other service threads being exceptional to some &ldquo;progress bar&rdquo; operations.</p>  <p>Only when I started designing code that heavily depended on multiple long-running dependent threads that I realized how much IoC libraries, including the core Spring Framework library, were not very good at handling service lifecycle. What if I want to cleanly unload an optional service? What if I want to load two versions of the same service at the same time? I can&rsquo;t bash those libraries too much since dealing with lifecycle events for unloading modules is difficult to properly implement. Why do you think that even in the latest version of Firefox you still can&rsquo;t unload a plug-in without restarting the whole process?</p>  <p>This is why I consider OSGi as a &ldquo;real&rdquo; microkernel. As in a real kernel, modules have independent classloaders. Modules can be loaded and unloaded at any time because only weak service references are kept. And it is almost <em>assumed</em> that each service represents one or more long running threads. So, a service reference (thead) plus it&rsquo;s own classloader roughly equals a &ldquo;process&rdquo; in the Java Virtual Machine running OSGi as its microkernel.</p>  <p>IoC can still be used with OSGi, especially as a way of linking all those service references together with some simple XML configuration and no additional code, using the <a href="http://www.springsource.org/osgi">Spring Dynamic Modules for OSGi Service Platforms</a> library. That way, I transformed my Singletons as module plus service &ldquo;processes&rdquo; for OSGi in no time.</p>  <p>Still, a problem remained: All those service treads (and in my case, thread pools) need to talk to each other. That felt like a huge design problem for me that would push me to my limits, yet I was sure somebody else already though about it before. Then, I contemplated this old book on my shelf about System V programming&hellip;</p>        </div>
