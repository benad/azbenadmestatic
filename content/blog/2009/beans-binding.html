---toml
title = "Beans Binding"
date = "2009-01-05T17:06:00-05:00"
permalink = "blog/2009/1/5/beans-binding/"
---

<p>A few months ago, a tutorial for <a href="http://www.netbeans.org/">NetBeans 6.5</a> called "<a href="http://www.netbeans.org/kb/docs/java/gui-db.html">Building a Java Desktop Database Application</a>" piqued my interest. It also linked to another tutorial called "<a href="http://www.netbeans.org/kb/60/java/gui-binding.html">Binding Beans &amp; Data in a Desktop Application</a>". While I've seen "build a GUI for your SQL database" demos a few dozen times already, this was different.</p>
<p>What was new to me was the <a href="https://beansbinding.dev.java.net/">Beans Binding</a> library, a subset of the <a href="https://appframework.dev.java.net/">Swing Application Framework</a>. While I've read about attempts to increase desktop integration with Swing before, I've never seen anything like Beans Binding. What it does is synchronize bean property values with Swing components or other bean properties. It does so by making use of <a href="http://java.sun.com/docs/books/tutorial/javabeans/events/index.html">bean events</a> that are generated by Swing components.</p>
<p>The implication of this is that rather than having the Swing components contain some values that are loaded or saved into the "model" from time to time, the Model and the View (in the "Model-View-Controller" design) are always synchronized automatically. As such, the Controller only needs to bind the View and the Model together. This is similar to the <a href="http://static.springframework.org/spring/docs/2.5.x/reference/mvc.html">Spring Web MVC</a> framework. Also, this means that you can have multiple Views on the same Model, and they will all be synchronized in real time.</p>
<p>There are a few things missing from Beans Binding though. It doesn't have a "generic" <tt>PropertyStateListener</tt> that updates a target bean's property when <tt>propertyStateChanged</tt> is called (that is, when the source property changed). I wrote one that, given the target bean and target property name, uses <tt>java.beans.Introspector</tt> and calls its write method automatically. Also, it lacks a binding mechanism that can automatically discover which properties to bind based on the introspection of property names and types. If it had that, binding two objects could be done in a single step in the Controller ("bind those two objects together").</p>
