---toml
title = "Client-Side JavaScript Modules"
date = "2014-08-14T23:14:41-04:00"
permalink = "blog/2014/8/14/client-side-javascript-modules/"
---

<p>I dislike the JavaScript programming language. I despise Node.js for server-side programming, and people with far more experience than me with both also agree, for example <a href="https://web.archive.org/web/20120306194613/http://teddziuba.com/2011/10/node-js-is-cancer.html">Ted Dziuba in 2011</a> and more recently <a href="http://notes.ericjiang.com/posts/751">Eric Jiang</a>. And while I can easily avoid using Node as a server-side solution, the same cannot be said about avoiding JavaScript altogether.</p>

<p>I recently discovered <a href="http://atom.io/">Atom</a>, a text editor based on a custom build of WebKit, essentially running on HTML, CSS and JavaScript. Though it is far from the fastest text editor out there, it feels like a spiritual successor to my favourite editor, <a href="http://www.jedit.org/">jEdit</a>, but based on modern web technologies rather than Java. The net effect is that Atom seems like the fastest growing text editor, and with its deep integration with Git (it was made by <a href="https://github.com/">Github</a>), it makes it a breeze to change code.</p>

<p>I noticed a few interesting things that were used to make JavaScript more tolerable in Atom. First, it supports <a href="http://coffeescript.org/">CoffeeScript</a>. Second, it uses Node-like modules.</p>

<p>CoffeeScript was a huge discovery for me. It is essentially a programming language that compiles into JavaScript, and makes JavaScript development more bearable. Its syntax reminds me a bit of the syntax difference between Java and Groovy. There's also the very interesting JavaScript to CoffeeScript converter called <a href="http://js2coffee.org/">js2coffee</a>. I used js2coffee on one of my JavaScript module, and the result was far more readable and manageable.</p>

<p>The problem with CoffeeScript is that you need to integrate its compilation to JavaScript <em>somewhere</em>. It just so happens that its compiler is a command-line JavaScript tool made for Node. A JavaScript equivalent to Makefiles (actually, more like <a href="https://maven.apache.org/">Maven</a>) is called <a href="http://gruntjs.com/">Grunt</a>, and from it you can call the CoffeeScript compiler directly, on top of <a href="http://marijnhaverbeke.nl//uglifyjs">UglifyJS</a> to make the generated output smaller. All of these tools exist under <code>node_modules/.bin</code> when installed locally using <code>npm</code>, the <a href="https://www.npmjs.org/">Node Package Manager</a>.</p>

<p>Also, by writing my module as a Node module (actually, <a href="http://www.commonjs.org/">CommonJS</a>), I could also use some dependency management and still deploy it for a web browser's environment using <a href="http://browserify.org/">Browserify</a>. I could even go further and integrate it with <a href="http://jasmine.github.io/">Jasmine</a> for unit tests, and run them in a GUI-less full-stack browser like <a href="http://phantomjs.org/">PhantomJS</a>, but that's going too far for now, and you're better off reading the <a href="https://blog.codecentric.de/en/2014/02/cross-platform-javascript/">Browserify article by Bastian Krol</a> for more information.</p>

<p>It remains that Browserify is kind of a hack that isn't ideal for running JavaScript modules in a browser, as it has to include browser-equivalent functionality that is unique to Node and isn't optimized for high-latency asynchronous loading. A better solution for browser-side JavaScript modules is <a href="http://requirejs.org/">RequireJS</a>, using the module format <a href="https://github.com/amdjs/amdjs-api/wiki/AMD">AMD</a>. While not all Node modules have an AMD equivalent, the major ones are easily accessible with <a href="http://bower.io/">bower</a>. Interestingly, you can create a module that can as AMD, Node and natively in a browser using the templates called <a href="https://github.com/umdjs/umd">UMD</a> (as in "Universal Module Definition"). Also, RequireJS can support Node modules (that don't use Node-specific functionality) and any other JavaScript library made for browsers, so that you can gain asynchronous loading.</p>

<p>It should be noted that bower, grunt and many command-line JavaScript tools are made for Node and installed locally using <code>npm</code>, So, even if "Node as a JavaScript web server" fails (and it should), using Node as an environment for local JavaScript command-line tools works quite well and could have a great future.</p>

<p>After all is said and done, I now have something that is kind of like Maven, but for JavaScript using Grunt, RequireJS, bower and Jasmine, to download, compile (CoffeeScript), inject and optimize JavaScript modules for deployment. Or you can use something like <a href="https://incident57.com/codekit/index.html">CodeKit</a> if you prefer a nice GUI. Either way, JavaScript development, for client-side software like Atom, command-line scripts or for the browser, is finally starting to feel reasonable.</p>
