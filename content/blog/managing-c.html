---toml
title = "Managing C"
date = "2012-04-24T21:58:40-04:00"
permalink = "blog/2012/4/25/managing-c/"
---

<div class='posterous_autopost'><p>Managing large amounts of C code within a single process can be quite daunting. If any single thing breaks, everything breaks spectacularly. It is not surprising that on Unix, the system C was originally made for, encourages modular, multi-process design that communicate through pipes. While this kind of modular design works well for multi-machine, distributed systems, it doesn&rsquo;t work too well most of the time, since code tends to be monolithic and not necessarily worth the high development overhead of that multi-process modularization.</p>  <p>The trick, of course, is to try to adhere to software design patters, which may help with validation and to avoid bugs as much as possible. Which led of course to C++, UML, and all those half-assed solutions. By that I mean is that what can truly help is some kind of run-time engine closely intertwined with the programming language that not only moves coding complexity to run-time behavior, but also can gracefully handle many types of programming errors.</p>  <p>Oh, I so much miss stack traces&hellip;</p></div>
