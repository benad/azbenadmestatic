<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!-->
<html class="no-js">
<!--<![endif]-->
	<head>
		<meta charset="utf-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
                <title>The Case for Complexity - Benad's Web Site</title>
		<meta name="description" content=""/>
		<meta name="viewport" content="width=device-width"/>
		<link rel="stylesheet" href="/css/bootstrap.css"/>
		<link rel="stylesheet" href="/css/bootstrap-responsive.css"/>
		<link rel="stylesheet" href="/css/main.css"/>
		<link rel="alternate" type="application/rss+xml" title="RSS" href="//feeds.feedburner.com/benad">
		<script src="/js/vendor/modernizr-2.6.2-respond-1.1.0.min.js"></script>
	</head>
	<body>
            <!--[if lt IE 7]>
		<p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/"> upgrade your browser</a> to improve your experience.</p>
                <![endif]-->
		<div class="container">

<div class="row">
        <h1 class="title">Benad's Web Site</h1>
        <h2 class="pageheader">The Case for Complexity</h2>
</div>
<div class="row">
        <div class="span2 pull-right sidebar">
                <p><a href="//benad.me/index.html">Home</a></p>
                <p><a href="/blog">Blog</a></p>
                <p><a href="//benad.me/me.html">About Me</a></p>
                <p><a href="//benad.me/meta.html">About This Site</a></p>
                <p><a href="//benad.me/articles.html">Articles</a></p>
                <p><a href="//benad.me/links.html">Links</a></p>
        </div>

        <div class="span8 offset2">
                <p>Like clockwork, there is a point in a programmer's career where one realizes that most programming tools suck, that not only they hinder the programmer's productivity, but worse may have an impact on the quality of the product for end users. And so, there are <a href="https://plus.google.com/116904230181415286707/posts/DnAMAN5sUR8">cries of the absurdity of it all</a>, some posit that complex software development tools must exist because <a href="http://250bpm.com/blog:42">some programmers like complexity above productivity</a>, while others long for the days where <a href="http://www.drdobbs.com/tools/just-let-me-code/240168735">programming was easier</a>.</p>

<p>I find these reactions amusing. Kind of a middle-life crisis for programmers. Trying to rationalize their careers, most just end up admitting defeat for a professional life of mediocrity, by using dumber tools and hoping to avoid the main reason why programming can be challenging. I went into that "programmer's existential crisis" in my third year as a programmer, just before deciding on making it a career, but I went out of it with what seems to be a conclusion seldom shared by my fellow programmers. To some extent this is why I don't <em>really</em> consider myself a programmer but rather a software designer.</p>

<p>The fundamental issue isn't the fact that software is (seemingly) unnecessarily complex, but rather trying to understand the source of that complexity. Too many programmers assume that programming is based on applied mathematics. Well, it <em>ought</em> to be, but programming as practiced in the industry is quite far from its computer science roots. That deviation isn't due only from programming mistakes, but due to the more irrational external constraints and requirements. Even existing bugs become part of the external constraints if they are in things you cannot fix but must "work around".</p>

<p>Those absurdities can come from two directions: Top-down, based on human need and mental models, or Bottom-up, based on faulty mathematical or software design models. Productive and efficient software development tools, by themselves, bring complexity above the programming language. Absurd business requirements, including cost-saving measures and dealing with buggy legacy systems not only bring complexity, but the workarounds they require bring even more absurd code.</p>

<p>Now, you may argue that abstractions make things simpler, and to some extent, they are. But abstractions only tend to <em>mask</em> complexity, and when things break or don't work as expected, that complexity re-surfaces. From the point of view of a typical user, if it's broken, you ask somebody else to fix it or replace it. But being a programmer <em>is</em> being that "somebody else" that takes responsibility into understanding, to some extent, that complexity.</p>

<p>You could argue that software should always be more usable first. And yet, usable software can be far more difficult to implement than software that is more "native" to its computing environment. All those manual pages, the flexible command-line parameters, those adaptive GUIs, pseudo-AIs, <a href="http://en.wikipedia.org/wiki/Clippy">Clippy</a>, and so on, bring enormous challenges to the implementation of any software <em>because</em> humans don't think like machines, and vice-versa. As long as users are involved, software cannot be fully "intuitive" for both users and computers at the same time. Computers are not "computing machines", but more sophisticated state machines made to run useful software for users. Gone are the days where room-sized computers just do "math stuff" for banks, where user interaction was limited to numbers and programmers. The moment there were personal computers, people didn't write "math-based software", but rather text-based games with code of dubious quality.</p>

<p>Complexity of software will always increase, because it can. Higher-level programming languages become more and more removed from the hardware execution model. Users keep asking for more features that don't necessarily "fit well", so either you add more buttons to that toolbar, or you create a brand new piece of software with its own interfaces. Even if by some reason computers stopped getting so much faster over time, it wouldn't stop users from asking for "more", and programmers from asking for "productivity".</p>

<p>My realization was that there has to be a balance between always increasing complexity and our ability to understand it. Sure, fifty years ago it would be reasonable to have a single person spend a few years to <em>fully</em> understand a complete computer system, but nowadays we just have to become specialized. Still, specialization is possible because we can understand a higher-level conceptual design of the other components rather than just an inconsistent mash up of absurdity. <em>Design</em> is the solution. Yes, things in software will always get bigger, but we can make it more reasonable to attempt to understand it all if, from afar, it was designed soundly rather than just accidentally "became". With design, complexity becomes a bit smaller and manageable, and even though only the programmers will have to deal with most of that complexity, good design produce qualities that become visible up to the end users. Good design makes tighter "vertical integration" easier since making sense of the whole system is easier.</p>

<p>Ultimately, making a better software product for the end users requires the programmer to take responsibility for the complexity of not only the software's code, but also of its environment. That means using sound design for any new code introduced, and accepting the potential absurdity of the rest. If you can't do that, then you'll never be more than a "code monkey".</p>

<h2 id="notes">Notes</h2>

<ol>
<li>Many programmers tend to assume that their code is logically sound, and that their errors are mostly due to menial mistakes. In my experience, it's the other way around: The buggiest code is produced when code isn't logically sound, and this is what happens most of the time, especially in scripting languages that have weak or implicit typing.</li>
<li>I use the term "complexity" more as the number of module connections than the average of <a href="https://en.wikipedia.org/wiki/Coupling_%28computer_science%29">module coupling</a>. I find "complexity as a sum" more intuitive from the point of view of somebody that has to be aware of the complete system: Adding an abstraction layer still adds a new integration point between the old and new code, adding more things that could break. This is why I normally consider programming tools added complexity, even though their code completion and generation can make the programmers more productive.</li>
</ol>

                <p>Published on July 30, 2014 at 22:14 EDT</p>
                <p>Older post: <a href="https://benad.me/blog/2014/7/12/running-final-fantasy-vii-steam-on-mac">Running Final Fantasy VII (Steam) on Mac</a></p>
                <p>Newer post: <a href="https://benad.me/blog/2014/8/14/client-side-javascript-modules">Client-Side JavaScript Modules</a></p>
        </div>
        <div id="disqus_thread" class="span8 offset2"></div>
</div>
			<footer>
				<hr/>
				<p>Benad's Web Site by Benoit Nadeau is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-sa/2.5/ca/">Creative Commons Attribution-Share Alike 2.5 Canada License</a></p>
			</footer>
		</div>
		<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
		<script>window.jQuery || document.write('<script src="/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
		<script src="/js/vendor/bootstrap.min.js"></script>
		<script src="/js/main.js"></script>
		<script>
		var _gaq=[['_setAccount','UA-6588628-1'],['_trackPageview']];
		(function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
		g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
		s.parentNode.insertBefore(g,s)}(document,'script'));
		</script>
		<script>
var disqus_config = function () {
this.page.url = window.location.protocol + "//" + window.location.hostname + "/blog/2014/7/30/the-case-for-complexity";
this.page.identifier = "https://benad.me/blog/2014/7/30/the-case-for-complexity";
this.page.title = "The Case for Complexity";
};
(function() {
if (window.location.hostname != 'benad.me')
    return;
var d = document, s = d.createElement('script');
var disqus_shortname = "benadmeblog";
s.src = '//' + disqus_shortname + '.disqus.com/embed.js';

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
	</body>
</html>

